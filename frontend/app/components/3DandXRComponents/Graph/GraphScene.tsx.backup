'use client';

import { useRef } from 'react';
import {
    Vector3,
    Color3,
    MeshBuilder,
    StandardMaterial,
    Scene,
    ArcRotateCamera,
    HemisphericLight,
    Mesh,
    ActionManager,
    ExecuteCodeAction,
    GlowLayer
} from '@babylonjs/core';
import * as GUI from '@babylonjs/gui';
import SceneComponent from '@/app/components/3DandXRComponents/Scene/SceneComponent';

interface GraphData {
    nodes: Array<{
        id: string;
        x: number;
        y: number;
        z: number;
        label?: string;
        color?: string;
        [key: string]: any;
    }>;
    edges: Array<{
        source: string;
        target: string;
        weight?: number;
        [key: string]: any;
    }>;
}

interface GraphSceneProps {
    data: GraphData;
    onSelect?: (data: any, type: 'node' | 'edge' | null, x?: number, y?: number) => void;
}

export default function GraphScene({ data, onSelect }: GraphSceneProps) {
    const sceneRef = useRef<Scene | null>(null);
    const xrHelperRef = useRef<any>(null);
    const detailsPlaneRef = useRef<Mesh | null>(null);

    const createVRDetailsPanel = (scene: Scene, data: any, type: string) => {
        if (detailsPlaneRef.current) {
            detailsPlaneRef.current.dispose();
            detailsPlaneRef.current = null;
        }

        if (!data) return;

        const plane = MeshBuilder.CreatePlane("detailsPlane", { width: 4, height: 3 }, scene);
        const camera = scene.activeCamera;
        if (camera) {
            const forward = camera.getForwardRay().direction;
            plane.position = camera.position.add(forward.scale(5));
            plane.lookAt(camera.position, Math.PI);
        }

        const advancedTexture = GUI.AdvancedDynamicTexture.CreateForMesh(plane);
        const panel = new GUI.StackPanel();
        panel.background = "#000000BB";
        advancedTexture.addControl(panel);

        const title = new GUI.TextBlock();
        title.text = type === 'node' ? (data.label || data.id) : "Lien";
        title.color = "white";
        title.fontSize = 50;
        title.height = "100px";
        panel.addControl(title);

        Object.entries(data).forEach(([key, value]) => {
            if (['id', 'x', 'y', 'z', 'source', 'target'].includes(key)) return;
            const text = new GUI.TextBlock();
            text.text = `${key}: ${value}`;
            text.color = "#AAAAAA";
            text.fontSize = 30;
            text.height = "50px";
            panel.addControl(text);
        });

        detailsPlaneRef.current = plane;
    };

    const onSceneReady = async (scene: Scene) => {
        sceneRef.current = scene;

        scene.clearColor = new Color3(0.01, 0.01, 0.03).toColor4();

        const camera = new ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 100, Vector3.Zero(), scene);
        const canvas = scene.getEngine().getRenderingCanvas();

        camera.attachControl(canvas, true);
        camera.wheelPrecision = 50;
        camera.lowerRadiusLimit = 10;
        camera.upperRadiusLimit = 500;
        camera.panningSensibility = 50;
        camera.pinchPrecision = 50;
        camera.wheelDeltaPercentage = 0.01;
        camera.inertia = 0.9;
        camera.angularSensibilityX = 1000;
        camera.angularSensibilityY = 1000;

        // Prevent page zoom
        if (canvas) {
            const preventZoom = (e: WheelEvent) => {
                if (e.ctrlKey || e.metaKey) e.preventDefault();
            };
            const preventTouchZoom = (e: TouchEvent) => {
                if (e.touches.length > 1) e.preventDefault();
            };
            canvas.addEventListener('wheel', preventZoom, { passive: false });
            canvas.addEventListener('touchmove', preventTouchZoom, { passive: false });
            const container = canvas.parentElement;
            if (container) {
                container.addEventListener('wheel', preventZoom, { passive: false });
                container.addEventListener('touchmove', preventTouchZoom, { passive: false });
            }
        }

        const light = new HemisphericLight("light", new Vector3(0, 1, 0), scene);
        light.intensity = 0.4;
        light.diffuse = new Color3(0.9, 0.9, 1);
        light.specular = new Color3(1, 1, 1);
        light.groundColor = new Color3(0.05, 0.05, 0.1);

        const { DirectionalLight } = await import('@babylonjs/core');
        const dirLight = new DirectionalLight("dirLight", new Vector3(-1, -2, -1), scene);
        dirLight.intensity = 0.2;
        dirLight.diffuse = new Color3(0.8, 0.8, 0.9);

        // Space background
        const spaceSphere = MeshBuilder.CreateSphere("spaceSphere", { diameter: 1000 }, scene);
        const spaceMat = new StandardMaterial("spaceMat", scene);
        spaceMat.backFaceCulling = false;
        spaceMat.disableLighting = true;
        spaceMat.emissiveColor = new Color3(0.01, 0.02, 0.05);
        spaceSphere.material = spaceMat;

        // Stars
        const starMat = new StandardMaterial("starMat", scene);
        starMat.emissiveColor = new Color3(0.8, 0.8, 1);
        starMat.disableLighting = true;

        for (let i = 0; i < 200; i++) {
            const star = MeshBuilder.CreateSphere(`star_${i}`, { diameter: 0.3 }, scene);
            const radius = 300 + Math.random() * 400;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;

            star.position = new Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            );

            const brightness = 0.3 + Math.random() * 0.7;
            const starMatClone = starMat.clone(`starMat_${i}`);
            starMatClone.emissiveColor = new Color3(brightness, brightness, brightness * 1.1);
            star.material = starMatClone;
        }

        const gl = new GlowLayer("glow", scene);
        gl.intensity = 0.5;

        // Node materials
        const nodeMaterial = new StandardMaterial("nodeMat", scene);
        nodeMaterial.diffuseColor = new Color3(0.3, 0.7, 1);
        nodeMaterial.emissiveColor = new Color3(0.1, 0.3, 0.5);
        nodeMaterial.specularColor = new Color3(1, 1, 1);

        const labelTexture = GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const nodeMeshes = new Map<string, Mesh>();

        // Create nodes
        data.nodes.forEach(node => {
            const sphere = MeshBuilder.CreateSphere(node.id, { diameter: 2 }, scene);
            sphere.position = new Vector3(node.x, node.y, node.z);
            sphere.material = nodeMaterial;

            if (node.label || node.id) {
                const label = new GUI.TextBlock();
                label.text = node.label || node.id;
                label.color = "white";
                label.fontSize = 14;
                label.outlineWidth = 2;
                label.outlineColor = "black";
                labelTexture.addControl(label);
                label.linkWithMesh(sphere);
                label.linkOffsetY = -30;
            }

            sphere.actionManager = new ActionManager(scene);
            sphere.actionManager.registerAction(
                new ExecuteCodeAction(ActionManager.OnPointerOverTrigger, () => {
                    sphere.renderOutline = true;
                    sphere.outlineColor = Color3.White();
                    sphere.outlineWidth = 0.1;
                })
            );
            sphere.actionManager.registerAction(
                new ExecuteCodeAction(ActionManager.OnPointerOutTrigger, () => {
                    sphere.renderOutline = false;
                })
            );
            sphere.actionManager.registerAction(
                new ExecuteCodeAction(ActionManager.OnPickTrigger, (evt) => {
                    const pointerX = scene.pointerX;
                    const pointerY = scene.pointerY;
                    if (onSelect) onSelect(node, 'node', pointerX, pointerY);
                    if (xrHelperRef.current && xrHelperRef.current.baseExperience.state === 2) {
                        createVRDetailsPanel(scene, node, 'node');
                    }
                })
            );

            nodeMeshes.set(node.id, sphere);
        });

        // Create edges
        data.edges.forEach(edge => {
            const sourceMesh = nodeMeshes.get(edge.source);
            const targetMesh = nodeMeshes.get(edge.target);

            if (sourceMesh && targetMesh) {
                const points = [sourceMesh.position, targetMesh.position];
                const line = MeshBuilder.CreateLines(`edge_${edge.source}_${edge.target}`, { points }, scene);
                line.color = new Color3(0.5, 0.5, 0.5);
                line.alpha = 0.3;
                line.isPickable = true;

                const tube = MeshBuilder.CreateTube(`tube_${edge.source}_${edge.target}`, {
                    path: points,
                    radius: 0.5,
                    updatable: false
                }, scene);
                tube.visibility = 0;

                tube.actionManager = new ActionManager(scene);
                tube.actionManager.registerAction(
                    new ExecuteCodeAction(ActionManager.OnPickTrigger, (evt) => {
                        const pointerX = scene.pointerX;
                        const pointerY = scene.pointerY;
                        if (onSelect) onSelect(edge, 'edge', pointerX, pointerY);
                        if (xrHelperRef.current && xrHelperRef.current.baseExperience.state === 2) {
                            createVRDetailsPanel(scene, edge, 'edge');
                        }
                        preferredHandedness: 'none',
                            overrideButtonId: 'xr-standard-trigger'
                    });

                // Hand tracking
                try {
                    featuresManager.enableFeature('hand-tracking' as any, 'latest', {
                        xrInput: xr.input
                    });
                } catch (e) {
                    console.log("Hand tracking unavailable");
                }

                // Near interaction
                try {
                    featuresManager.enableFeature('near-interaction' as any, 'stable', {
                        xrInput: xr.input,
                        farInteractionFeature: pointerSelection,
                        enableNearInteractionOnAllControllers: true
            const menuPanel = MeshBuilder.CreatePlane("vrMenu", { width: 2, height: 1.5 }, scene);
                        const camera = scene.activeCamera;
                        if(camera) {
                            menuPanel.position = new Vector3(-1.5, 1.5, 2);
                            menuPanel.billboardMode = Mesh.BILLBOARDMODE_ALL;
                        }

            const menuTexture = GUI.AdvancedDynamicTexture.CreateForMesh(menuPanel);
                        const mainPanel = new GUI.StackPanel();
                        mainPanel.width = "100%";
                        mainPanel.height = "100%";
                        mainPanel.background = "#000000DD";
                        mainPanel.paddingTop = "20px";
                        mainPanel.paddingBottom = "20px";
                        menuTexture.addControl(mainPanel);

                        const title = new GUI.TextBlock();
                        title.text = "ðŸŽ® MENU VR";
                        title.color = "white";
                        title.fontSize = 60;
                        title.height = "80px";
                        title.fontWeight = "bold";
                        mainPanel.addControl(title);

                        const spacer1 = new GUI.Rectangle();
                        spacer1.height = "20px";
                        spacer1.thickness = 0;
                        mainPanel.addControl(spacer1);

                        const exitButton = GUI.Button.CreateSimpleButton("exitVR", "ðŸšª Quitter VR");
                        exitButton.width = "80%";
                        exitButton.height = "120px";
                        exitButton.color = "white";
                        exitButton.fontSize = 50;
                        exitButton.background = "#FF4444";
                        exitButton.cornerRadius = 20;
                        exitButton.thickness = 0;

                        exitButton.onPointerEnterObservable.add(() => {
                            exitButton.background = "#FF6666";
                            exitButton.scaleX = 1.05;
                            exitButton.scaleY = 1.05;
                        });

                        exitButton.onPointerOutObservable.add(() => {
                            exitButton.background = "#FF4444";
                            exitButton.scaleX = 1.0;
                            exitButton.scaleY = 1.0;
                        });

                        exitButton.onPointerClickObservable.add(() => {
                            if (xr && xr.baseExperience) {
                                xr.baseExperience.exitXRAsync();
                                menuPanel.dispose();
                            }
                        });

                        mainPanel.addControl(exitButton);

                        const spacer2 = new GUI.Rectangle();
                        spacer2.height = "20px";
                        spacer2.thickness = 0;
                        mainPanel.addControl(spacer2);

                        const resetButton = GUI.Button.CreateSimpleButton("resetView", "ðŸ”„ Recentrer");
                        resetButton.width = "80%";
                        resetButton.height = "100px";
                        resetButton.color = "white";
                        resetButton.fontSize = 45;
                        resetButton.background = "#4444FF";
                        resetButton.cornerRadius = 20;
                        resetButton.thickness = 0;

                        resetButton.onPointerEnterObservable.add(() => {
                            resetButton.background = "#6666FF";
                        });

                        resetButton.onPointerOutObservable.add(() => {
                            resetButton.background = "#4444FF";
                        });

                        resetButton.onPointerClickObservable.add(() => {
                            const camera = scene.activeCamera as ArcRotateCamera;
                            if (camera) {
                                camera.alpha = -Math.PI / 2;
                                camera.beta = Math.PI / 2.5;
                                camera.radius = 100;
                                camera.target = Vector3.Zero();
                            }
                        });

                        mainPanel.addControl(resetButton);

                        const menuMaterial = new StandardMaterial("menuMat", scene);
                        menuMaterial.emissiveColor = new Color3(0.1, 0.1, 0.2);
                        menuMaterial.alpha = 0.95;
                        menuPanel.material = menuMaterial;
                    };

                    return (
                        <div className="h-full w-full overflow-hidden rounded-xl bg-black/20" style={{ touchAction: 'none' }}>
                            <SceneComponent
                                antialias
                                onSceneReady={onSceneReady}
                                id="graph-canvas"
                                className="h-full w-full outline-none"
                                style={{ touchAction: 'none' }}
                            />
                        </div>
                    );
                }
